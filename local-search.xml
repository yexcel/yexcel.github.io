<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java大纲</title>
    <link href="/posts/2302726656.html"/>
    <url>/posts/2302726656.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>Java存活路线</strong></p><span id="more"></span><h1 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h1><h2 id="01-项目性能优化"><a href="#01-项目性能优化" class="headerlink" title="01 项目性能优化"></a>01 项目性能优化</h2><ul><li><p>性能问题分析理论：3S&nbsp;定理</p></li><li><p>性能指标：RT、TPS、并发数…</p></li><li><p>压测监控平台：Docker、InfluxDB、Grafana、Prometheus 和 node_exporter 环境搭建</p></li><li><p>梯度压测：分析接口性能瓶颈</p></li><li><p>分布式压测：构建百万次请求的压力</p></li><li><p>服务容器优化：Tomcat、I/O 模型、Undertow&nbsp;调优</p></li><li><p>数据库调优：影响数据库性能因素</p></li><li><p>OpenResty 调优</p></li><li><p>多级缓存调优</p></li><li><p>JVM 调优</p></li></ul><h2 id="02-JVM虚拟机"><a href="#02-JVM虚拟机" class="headerlink" title="02 JVM虚拟机"></a>02 JVM虚拟机</h2><ul><li><p>JVM&nbsp;基本常识与整体架构</p></li><li><p>类加载子系统：加载时机、加载过程</p></li><li><p>类加载器详解</p></li><li><p>JVM 加载机制剖析：一个类的一生</p></li><li><p>双亲委派与打破双亲委派</p></li><li><p>自定义类加载器</p></li><li><p>JVM&nbsp;运行时数据区：堆、虚拟机栈、本地方法栈、方法区、字符串常量池、程序计数器</p></li><li><p>JVM 内存模型变迁</p></li><li><p>栈帧剖析与栈异常案例</p></li><li><p>字符串常量池如何存储和查找数据</p></li><li><p>方法区存储什么，永久代与元空间是什么关系</p></li><li><p>一个对象的一辈子：对象创建流程与内存分配</p></li><li><p>对象怎样才会进入老年代？内存担保机制</p></li><li><p>解剖对象这只小麻雀：对象内存布局，对象头 Header 的 MarkWord 和 KlassPoint</p></li><li><p>如何定位一个对象</p></li><li><p>GC 基本原理：什么是垃圾、如何找到垃圾、如何清除垃圾、用什么清除垃圾</p></li><li><p>垃圾收集器剖析：Parallel、Serial、CMS、G1、ZGC</p></li><li><p>Minor GC 、Major GC 和 Full GC</p></li><li><p>JVM&nbsp;核心参数：标准参数、非标准参数、不稳定参数</p></li><li><p>JVM&nbsp;常用指令：jps、jstat、jinfo、jhat、jmap</p></li><li><p>JVM&nbsp;调优工具：VisualVM、GC&nbsp;Easy、PerfMa、MAT</p></li><li><p>GC&nbsp;日志分析</p></li><li><p>GC&nbsp;日志分析工具</p></li><li><p>内存溢出与泄露案例</p></li><li><p>检测死锁案例</p></li><li><p>JVM&nbsp;调优实战案例：</p></li><li><p>堆内存和元空间优化</p></li><li><p>堆栈优化</p></li><li><p>吞吐量优先策略</p></li><li><p>响应时间优先策略</p></li><li><p>G1 全功能垃圾收集策略</p></li><li><p>JVM调优实战案例</p><ul><li><ul><li>堆内存和元空间优化</li></ul></li><li>堆栈优化</li><li>吞吐量优先策略</li><li>响应时间优先策略</li><li>G1 全功能垃圾收集策略</li></ul></li></ul><h2 id="03-多线程与并发编程"><a href="#03-多线程与并发编程" class="headerlink" title="03 多线程与并发编程"></a>03 多线程与并发编程</h2><ul><li><p>线程和进程、并发与并行、上下文切换</p></li><li><p>多线程并发中的线程安全问题</p></li><li><p>多线程并发的三个特性：原子性、可见性、顺序性分析</p></li><li><p>指令重排序、happens-before 规则</p></li><li><p>JMM&nbsp;模型深度剖析：JSR-133: Java Memory Model and Thread Specification</p></li><li><p>Synchronized&nbsp;原理分析</p></li><li><p>锁优化&amp;锁升级</p></li><li><p>Volatile&nbsp;原理与源码分析</p></li><li><p>多线程在 JVM 中的实现原理剖析</p></li><li><p>CAS 算法和 ABA 问题</p></li><li><p>显示锁和&nbsp;AQS&nbsp;底层原理分析</p></li><li><p>AQS&nbsp;共享锁实现原理</p></li><li><p>ReentrantLock 重入锁源码分析</p></li><li><p>ReentrantReadWriteLock 读写锁</p></li><li><p>并发容器深度剖析</p></li><li><p>CAS&nbsp;原子操作及相关类</p><ul><li><p>基本数据类型：AtomicInteger、AtomicLong、AtomicBoolean</p></li><li><p>数组：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</p></li><li><p>引用类型：AtomicReference</p></li></ul></li><li><p>并发编程工具掌握：CountDownLatch、Semaphore、CyclicBarrier</p></li><li><p>Future 和 FutureTask</p></li><li><p>线程池工作原理</p></li><li><p>ThreadLocal&nbsp;底层原理</p></li></ul><h2 id="04-网络编程"><a href="#04-网络编程" class="headerlink" title="04 网络编程"></a>04 网络编程</h2><ul><li><p>网络通信协议：TCP/IP 协议集</p></li><li><p>TCP/IP 五层模型和 OSI 模型详解</p></li><li><p>TCP 三次握手和四次挥手机制</p></li><li><p>TCP 与 UDP 协议</p></li><li><p>从输入 URL 地址到显示网页经历了哪些过程</p></li><li><p>HTTP/1.0 与 HTTP/1.1 的区别</p></li><li><p>URI 与 URL 的区别</p></li><li><p>HTTP 与 HTTPS 的区别</p></li><li><p>同步和异步、阻塞和非阻塞</p></li><li><p>五种&nbsp;I/O&nbsp;模型：阻塞&nbsp;I/O&nbsp;模型、非阻塞&nbsp;I/O&nbsp;模型、多路复用&nbsp;I/O&nbsp;模型、信号驱动&nbsp;I/O&nbsp;模型、异步&nbsp;I/O&nbsp;模型</p></li><li><p>JAVA&nbsp;网络编程模型：BIO、NIO、AIO</p></li><li><p>NIO 多路复用深入剖析：Selector、Channel 与 SelectionKey</p></li><li><p>NIO 案例 01：客户端与服务器之间通信</p></li><li><p>NIO 案例 02：网络聊天室 V1.0</p></li><li><p>Netty&nbsp;总体架构设计</p></li><li><p>Netty&nbsp;线程模型：单线程、多线程与 Netty 线程模型</p></li><li><p>Netty&nbsp;核心组件：Bootstrap、EventLoopGroup、Channel 与 ChannelHandlerContext 等</p></li><li><p>Netty 案例 03：客户端与服务器之间通信</p></li><li><p>Netty 案例 04：网络聊天室 V2.0</p></li><li><p>Netty 编解码器</p></li><li><p>RPC&nbsp;通信原理</p></li><li><p>RPC&nbsp;的设计架构与思想</p></li><li><p>RPC&nbsp;架构完整调用流程</p></li><li><p>案例 05：手写一个 RPC 框架 HeroRPC</p></li><li><p>案例 06：手写一个 Tomcat</p></li><li><p>案例 07：600W+ 连接网络应用实战</p></li></ul><h1 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h1><h2 id="01MySQL进阶"><a href="#01MySQL进阶" class="headerlink" title="01MySQL进阶"></a>01MySQL进阶</h2><ul><li><p>MySQL&nbsp;应用架构：内存结构、磁盘结构</p></li><li><p>MySQL&nbsp;体系架构</p></li><li><p>MySQL&nbsp;运行机制</p></li><li><p>一条&nbsp;SQL&nbsp;语句的完整执行流程</p></li><li><p>Buffer&nbsp;Pool</p></li><li><p>日志缓冲</p></li><li><p>内存数据落盘</p></li><li><p>CheckPoint</p></li><li><p>Double&nbsp;Write</p></li><li><p>存储引擎原理：InnoDB、MyISAM</p></li><li><p>索引的数据结构：B+&nbsp;树、为什么不用红黑树、二叉树、B&nbsp;树？</p></li><li><p>索引原理</p></li><li><p>索引分析与优化建议</p></li><li><p>索引下推&nbsp;ICP</p></li><li><p>聚簇索引，辅助索引</p></li><li><p>查询分析与优化</p></li><li><p>事务&nbsp;ACID&nbsp;特性</p></li><li><p>事务控制的演进</p></li><li><p>事务隔离级别</p></li><li><p>LBCC&nbsp;与&nbsp;MVCC</p></li><li><p>ReadView：快照读、当前读</p></li><li><p>版本链</p></li><li><p>日志：Undo&nbsp;log、redo&nbsp;log、binlog</p></li><li><p>锁：全局锁、表锁、行锁【记录锁、间隙锁、临键锁、插入意向锁】、读锁、写锁</p></li><li><p>复杂&nbsp;SQL&nbsp;加锁分析</p></li><li><p>死锁原理</p></li></ul><h2 id="02-海量数据存储与优化"><a href="#02-海量数据存储与优化" class="headerlink" title="02 海量数据存储与优化"></a>02 海量数据存储与优化</h2><ul><li><p>数据库压力测试</p></li><li><p>数据库的连接池优化</p></li><li><p>SQL&nbsp;语句优化：执行计划</p></li><li><p>索引优化</p></li><li><p>Limit&nbsp;优化</p></li><li><p>子查询优化</p></li><li><p>SQL&nbsp;语句性能分析</p></li><li><p>慢查询日志</p></li><li><p>线程使用情况分析</p></li><li><p>集群架构设计</p></li><li><p>主从模式高可用</p></li><li><p>双主模式</p></li><li><p>分库分表</p></li><li><p>分库分表实战</p></li><li><p>ShardingSphere</p></li><li><p>Sharding-JDBC</p></li><li><p>数据分片剖析实战</p></li><li><p>读写分离剖析实战</p></li><li><p>分布式事务剖析实战</p></li><li><p>Sharding-Proxy&nbsp;实战</p></li><li><p>Sharding&nbsp;Sphere&nbsp;源码分析</p></li><li><p>MyCat&nbsp;核心概念</p></li><li><p>MyCat&nbsp;架构剖析</p></li><li><p>MyCat&nbsp;配置详解</p></li><li><p>MyCat&nbsp;管理命令详解</p></li><li><p>MyCat&nbsp;分片规则详解</p></li><li><p>MyCat&nbsp;分库分表</p></li><li><p>MyCat&nbsp;读写分离</p></li><li><p>MyCat&nbsp;强制路由</p></li><li><p>MyCat&nbsp;注解技术</p></li><li><p>MyCat&nbsp;核心技术分析</p></li><li><p>MyCat&nbsp;分布式事务的实现</p></li><li><p>MyCat&nbsp;SQL&nbsp;路由的实现</p></li><li><p>MyCat&nbsp;跨库&nbsp;JSON&nbsp;的实现</p></li><li><p>MyCat&nbsp;数据汇聚和排序的实现</p></li></ul><h2 id="03-MongoDB"><a href="#03-MongoDB" class="headerlink" title="03&nbsp;MongoDB"></a>03&nbsp;MongoDB</h2><ul><li><p>MongoDB&nbsp;体系结构</p></li><li><p>MongoDB&nbsp;存储原理</p></li><li><p>MongoDB&nbsp;存储引擎</p></li><li><p>MongoDB&nbsp;索引和&nbsp;explain&nbsp;分析</p></li><li><p>MongoDB&nbsp;索引底层原理分析</p></li><li><p>MongoDB&nbsp;主备切换</p></li><li><p>MongoDB&nbsp;企业实战</p></li><li><p>MongoDB&nbsp;集群高可用</p></li><li><p>复制集&nbsp;replica&nbsp;sets</p></li><li><p>分片集群&nbsp;Shard&nbsp;Cluster</p></li><li><p>MongoDB&nbsp;安全认证</p></li><li><p>监控服务（Mong&nbsp;oOps&nbsp;Manager）</p></li><li><p>MongoDB&nbsp;备份</p></li></ul><h2 id="04-FastDFS"><a href="#04-FastDFS" class="headerlink" title="04&nbsp;FastDFS"></a>04&nbsp;FastDFS</h2><ul><li><p>分布式文件系统</p></li><li><p>FastDFS&nbsp;特性</p></li><li><p>FastDFS&nbsp;的构成</p></li><li><p>Linux&nbsp;下&nbsp;FastDFS&nbsp;的安装</p></li><li><p>Java&nbsp;访问&nbsp;FastDFS</p></li><li><p>FastDFS&nbsp;系统架构</p></li><li><p>FastDFS&nbsp;功能原理</p></li><li><p>FastDFS&nbsp;集群和配置优化</p></li><li><p>FastDFS&nbsp;企业实战</p></li><li><p>Spring Boot&nbsp;访问&nbsp;FastDFS</p></li></ul><h1 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h1><hr><h2 id="01-Spring-源码"><a href="#01-Spring-源码" class="headerlink" title="01&nbsp;Spring 源码"></a>01&nbsp;<strong>Spring 源码</strong></h2><ul><li><p>Spring&nbsp;源码阅读前沿</p></li><li><p>Spring 创建对象代码演变及 IoC&nbsp;容器初始化</p></li><li><p>手写一个 Spring 框架案例</p></li><li><p>Spring&nbsp;面向对象 OOAD 和七大设计原则</p></li><li><p>Spring-IoC 模块的面向对象设计</p></li><li><p>Spring&nbsp;面向对象方式手写 IoC 流程</p></li><li><p>Spring-IoC 源码阅读</p></li><li><p>Spring-AOP 核心概念以及动态代理原理</p></li><li><p>Spring-AOP 三大核心流程图解</p></li><li><p>Spring-AOP 源码阅读</p></li><li><p>Spring&nbsp;中的设计模式：责任链模式与反射调用</p></li></ul><h2 id="02-Spring-MVC-源码"><a href="#02-Spring-MVC-源码" class="headerlink" title="02&nbsp;Spring MVC 源码"></a>02&nbsp;<strong>Spring MVC 源码</strong></h2><ul><li><p>手写一个 Spring MVC Web 应用框架</p></li><li><p>Spring MVC 应用框架架构解析</p></li><li><p>手写一个 Spring 框架案例</p></li><li><p>图解 Spring MVC 执行流程</p></li><li><p>Spring MVC 源码阅读</p></li><li><p>解析 RequestMappingAdapter 流程</p></li></ul><h2 id="03-Spring-Boot-应用"><a href="#03-Spring-Boot-应用" class="headerlink" title="03&nbsp;Spring Boot 应用"></a>03&nbsp;<strong>Spring Boot 应用</strong></h2><ul><li><p>Spring Boot 与 Spring 的区别与联系</p></li><li><p>Spring Boot 启动流程源码解析</p></li><li><p>yml 配置文件加载流程解析</p></li><li><p>图解 Spring Boot 自动配置流程</p></li><li><p>Spring Boot&amp;Redis&amp;MyBatis 整合源码解析</p></li><li><p>使用自定义 starter 完成案例</p></li></ul><h2 id="04-MyBatis-源码"><a href="#04-MyBatis-源码" class="headerlink" title="04&nbsp;MyBatis 源码"></a>04&nbsp;<strong>MyBatis 源码</strong></h2><ul><li><p>采用面向的对象方式手写一个 MyBatis 框架</p></li><li><p>解析 MyBatis 版本配置文件及对应存储类分析</p></li><li><p>MyBatis-SqlSession 执行流程解析</p></li><li><p>MyBatis-Mapper 代理底层原理解析</p></li></ul><h2 id="05-Tomcat-源码"><a href="#05-Tomcat-源码" class="headerlink" title="05&nbsp;Tomcat 源码"></a>05&nbsp;<strong>Tomcat 源码</strong></h2><ul><li><p>Tomcat 底层原理解析</p></li><li><p>搭建 Tomcat 源码环境</p></li><li><p>手写 Tomcat 源码</p></li><li><p>阅读解析 Tomcat 启动流程</p></li><li><p>Tomcat 加载、创建 Servlet 流程源码解读</p></li><li><p>解析 Tomcat 请求处理流程</p></li></ul><h1 id="06-Nginx-应用"><a href="#06-Nginx-应用" class="headerlink" title="06&nbsp;Nginx 应用"></a>06&nbsp;<strong>Nginx 应用</strong></h1><ul><li><p>Nginx 使用原理解析</p></li><li><p>Web Server 技术选型</p></li><li><p>详解 Nginx 配置文件</p></li><li><p>Nginx 请求定位之 server 定位</p></li><li><p>Nginx 请求定位之 location 定位</p></li><li><p>Nginx 应用之 rewrite 重定向</p></li><li><p>Nginx 应用实战之静态资源服务器</p></li><li><p>Nginx 应用实战之反向代理应用</p></li><li><p>Nginx 应用实战之负载均衡</p></li><li><p>Nginx 应用实战之动静分离</p></li><li><p>Nginx 应用实战之虚拟主机应用</p></li><li><p>Nginx 应用实战之缓存配置</p></li><li><p>Nginx 应用实战之日志管理</p></li></ul><h1 id="四阶段：分布式缓存-搜索专题"><a href="#四阶段：分布式缓存-搜索专题" class="headerlink" title="四阶段：分布式缓存&amp;搜索专题"></a>四阶段：分布式缓存&amp;搜索专题</h1><h2 id="01-Redis"><a href="#01-Redis" class="headerlink" title="01&nbsp;Redis"></a>01&nbsp;Redis</h2><ul><li><p>Redis 底层数据结构的空间使用情况、时间复杂度</p></li><li><p>数据结构原理与场景实战</p></li><li><p>Redis 网络模型：阻塞&amp;非阻塞</p></li><li><p>用户态&amp;内核态</p></li><li><p>I/O 多路复用</p></li><li><p>Redis 单线程</p></li><li><p>Redis RESP 通信协议</p></li><li><p>Redis 的内存淘汰、内存布局、key 过期机制</p></li><li><p>Redis 最佳实践：key 设计原则，bigkey、hotkey 的发现方式和避免手段</p></li><li><p>Redis 批处理的场景和不足，分析 Redis 数据安全问题。</p></li><li><p>Redis 服务端优化之持久化原理和常见配置</p></li><li><p>Redis 服务端优化之命令安全、内存安全配置</p></li><li><p>Redis 运维之主从同步、哨兵、集群分片实现原理</p></li><li><p>Redis 场景实战</p></li></ul><h2 id="02-Elasticsearch"><a href="#02-Elasticsearch" class="headerlink" title="02&nbsp;Elasticsearch"></a>02&nbsp;Elasticsearch</h2><ul><li><p>Elasticsearch 倒排索引</p></li><li><p>FOR 算法、RoaringBitMap 算法原理</p></li><li><p>前缀树、FST 原理解析</p></li><li><p>Elasticsearch 之集群分片</p></li><li><p>Elasticsearch 全文搜索 match、精准查询 term</p></li><li><p>Elasticsearch 过滤器</p></li><li><p>Elasticsearch 组合查询、模糊查询</p></li><li><p>scriptings 脚本</p></li><li><p>Elasticsearch 分词过滤</p></li><li><p>Elasticsearch 文档</p></li><li><p>外部词库更新</p></li><li><p>分词器 tokenizer</p></li><li><p>Elasticsearch 聚合查询</p></li><li><p>Elasticsearch 场景实战</p></li></ul><h1 id="五阶段：消息队列专题"><a href="#五阶段：消息队列专题" class="headerlink" title="五阶段：消息队列专题"></a>五阶段：消息队列专题</h1><h2 id="01-消息中间件介绍"><a href="#01-消息中间件介绍" class="headerlink" title="01&nbsp;消息中间件介绍"></a>01&nbsp;消息中间件介绍</h2><ul><li><p>消息中间件使用场景</p></li><li><p>消息中间件需要解决的问题</p></li><li><p>消息中间件选型</p></li><li><p>领域模型介绍</p></li><li><p>RocketMQ&nbsp;环境搭建、Debug&nbsp;调试</p></li></ul><h2 id="02-RocketMQ-实战"><a href="#02-RocketMQ-实战" class="headerlink" title="02&nbsp;RocketMQ&nbsp;实战"></a>02&nbsp;RocketMQ&nbsp;实战</h2><ul><li><p>消息发送&nbsp;API&nbsp;详解与版本变迁说明</p></li><li><p>消息发送核心参数与工作原理</p></li><li><p>消息发送常见错误与解决方案</p></li><li><p>事务消息以及定时消息发送实战</p></li><li><p>消息消费&nbsp;API&nbsp;详解与版本变迁说明</p></li><li><p>DefaultMQPushConsumer&nbsp;核心参数与工作原理</p></li><li><p>DefaultMQPushConsumer&nbsp;使用示例与注意事项</p></li><li><p>结合应用场景学习&nbsp;DefaultMQPushConsumer</p></li><li><p>消息过滤实战</p></li><li><p>消息消费积压问题排查实战</p></li><li><p>订阅关系不一致实战</p></li><li><p>批量消费实战</p></li></ul><h2 id="03-RocketMQ-原理应用"><a href="#03-RocketMQ-原理应用" class="headerlink" title="03&nbsp;RocketMQ&nbsp;原理应用"></a>03&nbsp;RocketMQ&nbsp;原理应用</h2><ul><li><p>Broker&nbsp;启动流程分析</p></li><li><p>NameServer&nbsp;路由注册机制</p></li><li><p>生产者的发送消息流程</p></li><li><p>消费者的接收消息流程</p></li><li><p>消息的可靠性应该如何保证</p></li><li><p>不同消息的有序性如何解决</p></li><li><p>Broker&nbsp;接收消息的处理流程</p></li></ul><h2 id="04-RocketMQ-高级特性"><a href="#04-RocketMQ-高级特性" class="headerlink" title="04&nbsp;RocketMQ&nbsp;高级特性"></a>04&nbsp;RocketMQ&nbsp;高级特性</h2><ul><li><p>消息在&nbsp;Broker&nbsp;端的文件布局</p></li><li><p>消息存储的高效与刷盘策略</p></li><li><p>Broker&nbsp;快速读取消息机制</p></li><li><p>文件恢复与&nbsp;CheckPoint&nbsp;机制</p></li><li><p>消息大量堆积了该怎么办</p></li><li><p>部署架构与高可用机制</p></li><li><p>NameServer&nbsp;的设计理念</p></li></ul><h2 id="05-Kafka-实战"><a href="#05-Kafka-实战" class="headerlink" title="05&nbsp;Kafka&nbsp;实战"></a>05&nbsp;Kafka&nbsp;实战</h2><ul><li><p>Kafka&nbsp;基础架构运行流程</p></li><li><p>生产者选择分区发送数据流程</p></li><li><p>生产者发送数据的可靠性保证</p></li><li><p>服务端的消息处理架构模型</p></li><li><p>服务端消息存储的文件布局</p></li><li><p>如何保证服务端数据的一致性</p></li><li><p>消费方如何消费数据/消费分区</p></li><li><p>Kafka&nbsp;该如何实现顺序消费</p></li><li><p>消费者组重平衡流程解析</p></li><li><p>Kafka&nbsp;有哪些高性能的设计</p></li><li><p>Kafka&nbsp;与&nbsp;RocketMQ&nbsp;的主流功能对比</p></li></ul><h1 id="六阶段：微服务前沿技术栈专题"><a href="#六阶段：微服务前沿技术栈专题" class="headerlink" title="六阶段：微服务前沿技术栈专题"></a>六阶段：微服务前沿技术栈专题</h1><h2 id="01-体系介绍"><a href="#01-体系介绍" class="headerlink" title="01&nbsp;体系介绍"></a>01&nbsp;体系介绍</h2><ul><li>Nacos Registry</li><li>Nacos Config</li><li>OpenFeign</li><li>Gateway </li><li>Dubbo</li><li>Sentinel</li><li>Seata</li></ul><h2 id="02-Spring-Cloud-最佳实践"><a href="#02-Spring-Cloud-最佳实践" class="headerlink" title="02 Spring Cloud 最佳实践"></a>02 Spring Cloud 最佳实践</h2><ul><li><p>Provider + Consumer + Eureka 服务搭建</p></li><li><p>Provider + Consumer + Nacos 服务搭建</p></li><li><p>Consumer + Provider + Nginx 集群搭建</p></li></ul><h2 id="03-Nacos-注册与发现"><a href="#03-Nacos-注册与发现" class="headerlink" title="03 Nacos 注册与发现"></a>03 Nacos 注册与发现</h2><ul><li><p>Nacos 服务注册案例搭建</p></li><li><p>Nacos 服务订阅案例搭建</p></li><li><p>Nacos Client 发起注册流程</p></li><li><p>Nacos Server 处理注册流程</p></li><li><p>Nacos Client 发起订阅流程</p></li><li><p>Nacos 心跳与剔除机制</p></li></ul><h2 id="04-Nacos-配置中心"><a href="#04-Nacos-配置中心" class="headerlink" title="04 Nacos 配置中心"></a>04 Nacos 配置中心</h2><ul><li><p>Nacos Config 动态更新端口案例搭建</p></li><li><p>Nacos Config 动态更新配置案例搭建</p></li><li><p>Nacos 配置中心源码分析</p></li><li><p>Nacos 动态更新机制</p></li><li><p>Nacos UDP 通知更新机制</p></li><li><p>Nacos 集群同步源码分析之 CP + AP 模式</p></li><li><p>Nacos 集群同步 Distro 一致性协议</p></li><li><p>Nacos 集群同步 Raft 一致性协议</p></li></ul><h2 id="05-OpenFeign-负载均衡"><a href="#05-OpenFeign-负载均衡" class="headerlink" title="05 OpenFeign 负载均衡"></a>05 OpenFeign 负载均衡</h2><ul><li><p>Ribbon 工程案例搭建</p></li><li><p>OpenFeign 负载均衡与降级案例搭建</p></li><li><p>OpenFeign 源码分析之 @FeignClient 注解扫描机制</p></li><li><p>OpenFeign 源码分析之 Feign 的上下文隔离机制</p></li></ul><h2 id="06-Gateway-网关路由"><a href="#06-Gateway-网关路由" class="headerlink" title="06 Gateway 网关路由"></a>06 Gateway 网关路由</h2><ul><li><p>Gateway 路由案例搭建</p></li><li><p>自定义拦截过滤</p></li><li><p>转发重定向机制</p></li></ul><h2 id="07-Sentinel-限流降级"><a href="#07-Sentinel-限流降级" class="headerlink" title="07 Sentinel 限流降级"></a>07 Sentinel 限流降级</h2><ul><li><p>Sentinel 手动设置限流/降级案例搭建</p></li><li><p>Sentinel 接入 Nacos 案例搭建</p></li><li><p>探索 Sentinel 规则持久化机制</p></li><li><p>联动 Sentinel 与 Nacos 的持久化实现</p></li><li><p>核心 SphU.entry 源码分析</p></li><li><p>ProcessorSlotChain 过滤器链流程</p></li><li><p>StatisticSlot 核心处理逻辑分水岭</p></li></ul><h2 id="08-Dubbo-服务调用框架"><a href="#08-Dubbo-服务调用框架" class="headerlink" title="08 Dubbo 服务调用框架"></a>08 Dubbo 服务调用框架</h2><ul><li><p>Dubbo 工程案例环境搭建</p></li><li><p>Provider &amp; Consumer 案例搭建</p></li><li><p>依赖检查 &amp; 负载均衡案例搭建</p></li><li><p>广播调用 &amp; 缓存操作案例搭建</p></li><li><p>点对点调用案例搭建</p></li><li><p>泛化调用案例搭建</p></li><li><p>Dubbo 源码分析</p></li><li><p>JDK SPI 与 Dubbo SPI 机制</p></li><li><p>Dubbo 服务发布流程</p></li><li><p>Dubbo 服务订阅流程</p></li><li><p>Dubbo Wrapper 机制</p></li><li><p>Dubbo 协议编解码</p></li></ul><h1 id="七阶段：持续集成与容器化专题"><a href="#七阶段：持续集成与容器化专题" class="headerlink" title="七阶段：持续集成与容器化专题"></a>七阶段：持续集成与容器化专题</h1><h2 id="01-CI-CD、DevOps"><a href="#01-CI-CD、DevOps" class="headerlink" title="01&nbsp;CI/CD、DevOps"></a>01&nbsp;CI/CD、DevOps</h2><ul><li><p>软件生命周期概念</p></li><li><p>CI/CD 概念</p></li><li><p>DevOps 概念</p></li><li><p>搭建实验环境</p></li><li><p>初识 Jenkins</p></li><li><p>Jekins 集成 Maven 构建 Java 应用程序</p></li><li><p>Jekins 集成 Git 搭建 GitLab 服务器</p></li><li><p>Jenkins 集成 GitLab 管理 Java 应用程序</p></li><li><p>Jenkins Security 用户角色管理</p></li><li><p>Jenkins 自动化任务</p></li><li><p>Jenkins 流水线 Pipeline</p></li><li><p>Jenkins 实战之集成 Ansible</p></li><li><p>Jenkins 实战之搭建 CI/CD 流水线</p></li></ul><h2 id="02-Docker"><a href="#02-Docker" class="headerlink" title="02&nbsp;Docker"></a>02&nbsp;Docker</h2><ul><li><p>Jenkins 基础&amp;安装流程</p></li><li><p>虚拟化技术 vs 容器化原理</p></li><li><p>Docker&nbsp;client 命令详解</p></li><li><p>Docker&nbsp;交互指令</p></li><li><p>Docker&nbsp;镜像概念</p></li><li><p>Docker&nbsp;实战部署 Web 服务</p></li><li><p>Docker-compose 部署多容器应用</p></li><li><p>Docker 进阶：container 概念详解</p></li><li><p>Docker 进阶：network 概念详解</p></li><li><p>Docker 进阶：image 概念详解</p></li><li><p>Docker 进阶：volume 概念详解</p></li><li><p>Docker Swarm：微服务项目容器化部署</p></li><li><p>Docker compose vs Docker Swarm</p></li><li><p>Docker 私服搭建</p></li></ul><h2 id="03-Kubernetes"><a href="#03-Kubernetes" class="headerlink" title="03&nbsp;Kubernetes"></a>03&nbsp;Kubernetes</h2><ul><li><p>K8s&nbsp;集群搭建</p></li><li><p>Harbor&nbsp;仓库搭建</p></li><li><p>K8s&nbsp;基本指令入门</p></li><li><p>K8s&nbsp;核心组件原理</p></li><li><p>K8s&nbsp;网络原理</p></li><li><p>K8s&nbsp;负载均衡</p></li><li><p>POD&nbsp;调度详解、重启策略</p></li><li><p>容器探针</p></li><li><p>POD&nbsp;核心原理剖析</p></li><li><p>Ingress&nbsp;七层负载君合实战方案</p></li><li><p>ReplicaSet&nbsp;剖析</p></li><li><p>configmap&nbsp;资源对象剖析</p></li><li><p>K8s&nbsp;存储解析</p></li><li><p>PVC&nbsp;和&nbsp;PV&nbsp;深度剖析</p></li><li><p>headless&nbsp;Service&nbsp;原理解析</p></li><li><p>statefulSet&nbsp;原理解析</p></li><li><p>有状态服务部署</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>学习路线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>技术路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>尝试篇</title>
    <link href="/posts/3125928431.html"/>
    <url>/posts/3125928431.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note note-info">            <p>记录自己做过的尝试，无论事情大小，重在尝试</p>          </div><span id="more"></span><h1 id="扇贝一天背单词达到800"><a href="#扇贝一天背单词达到800" class="headerlink" title="扇贝一天背单词达到800"></a>扇贝一天背单词达到800</h1><hr><p><img src="/posts/3125928431/1b44d28ac7591d016fc8601febfaada.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>人生体验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>尝试</tag>
      
      <tag>体验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10月 - 每日反省</title>
    <link href="/posts/2662318435.html"/>
    <url>/posts/2662318435.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>记录10月每日收获</li></ul><span id="more"></span><h1 id="26日"><a href="#26日" class="headerlink" title="26日"></a>26日</h1><hr><p>学习了行列式的性质，五个字<strong>转换加乘拆</strong>，即转置、变换、倍加、数乘和拆分</p><ul><li>转置：行变成列，①行变成①列，n行变成n列…；并且转置之后等于原行列式</li><li>变换：行列式的两行或者两列相互交换位置，整个行列式要变号；变换一次要变一次号</li><li>倍加：某一行（列）的k倍之后加到另外一行（列）上，行列式值不变</li><li>数乘：某一行或者某一列乘以一个数字相当于<strong>整个行列式</strong>乘以这个数</li><li>拆分：针对行列式中加减的情况，一行（列）进行拆分，但是其余行（列）不变；<strong>一行（列）拆开，其余行（列）不变</strong><blockquote><p>其中：<br>1：如果两行或者两列相同，则行列式值为0<br>2：数乘可以用来提炼某一行（列）的公因子实现化简行列式<br>3：一行（列）对应位置元素是另外一行（列）的倍数，则行列式值=0<br>4：倍加用来<strong>造0</strong>化简</p></blockquote></li></ul><h1 id="27日"><a href="#27日" class="headerlink" title="27日"></a>27日</h1><hr><p>  今天学习了行列式的按行展开和按列展开、余子式和代数余子式。主要利用一行或者一列中含0量高的那行（列），无论是二阶还是三阶都可以用行列式的展开来快速求解，相比于之前的使用行列式的性质（转换加倍分）来的快，但是这一块因为老师上课不好演示，学起来比较困难。</p><p>  上午做行列式性质的时候，遇到一种有特点的题，就是无论哪一行，那一行所有元素加起来的和都是相同的，此题型的解题方法为：将第一列后面的几列全部加到第一列，然后第一列所有的元素都是相同的和，然后将这个和提到行列式的外面，然后第一列全都是1，此时再用行列式性质进行<strong>造0</strong>求解。</p><h1 id="28日"><a href="#28日" class="headerlink" title="28日"></a>28日</h1><hr><p>  上午开论文会，下午写论文写到回宿舍，回宿舍之后又帮其他宿舍的两个同学的代码搞了一下，搞到凌晨才回去。所以，收获几乎为0。</p><h1 id="29日"><a href="#29日" class="headerlink" title="29日"></a>29日</h1><hr><p>  今天白天一直都在做数学，晚上来把论文赶出来。<br>  数学学了行列式的按行展开按列展开的逆用，自己补充了异乘变零定理：一行（列）和另一行（列）的代数余子式相乘的和为0。此外还学了矩阵：概念，加减乘，一些特殊矩阵（单位矩阵、上三角矩阵、下三角…);<br>  计算四阶行列式步骤多，而且对不同的行或列进行造0很容易导致结果不同，这个地方需要自己大量练习计算。<br>  还有两天，数学继续干。</p><h1 id="30日"><a href="#30日" class="headerlink" title="30日"></a>30日</h1><hr><p>  今天上午在完善论文，一直在画E-R图，下午写论文，晚上改论文，单词背了四五百，其他无。属于是白忙活的一天。</p>]]></content>
    
    
    <categories>
      
      <category>反省</category>
      
      <category>10月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Plans for 2024</title>
    <link href="/posts/2479467106.html"/>
    <url>/posts/2479467106.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>2024年升级清单</p><span id="more"></span><p><strong>10月</strong></p><ol><li>数学基础班学完</li><li>英语单词6000词重新过2轮</li></ol><hr><p><strong>11月</strong></p><ol><li>数学所有课程做一遍</li><li>英语套卷做30套，作文每种模板背十篇，听力把全国所有的听力过一轮</li><li>专业课的PDF全部看完并熟知，时间充裕就做文字输出</li><li>月末总结出自身的学习体系（流程 + 方法 + 细节）</li></ol><hr><p><strong>12月</strong></p><ul><li>待定</li></ul>]]></content>
    
    
    <categories>
      
      <category>年度</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度期待</tag>
      
      <tag>Planning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排版工具 - Typst</title>
    <link href="/posts/3498028646.html"/>
    <url>/posts/3498028646.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>放置一些我个人喜欢用的一些工具</strong></p><span id="more"></span><h1 id="Typst-平替Latex的新一代工具"><a href="#Typst-平替Latex的新一代工具" class="headerlink" title="Typst 平替Latex的新一代工具"></a>Typst 平替Latex的新一代工具</h1><hr><ul><li><a href="https://typst-doc-cn.github.io/guide/quick-start.html">中文社区导航</a></li><li><a href="https://typst.app/">官网使用Typst</a></li><li><a href="https://typst-doc-cn.github.io/docs/tutorial/writing-in-typst/">中文教程</a></li><li><a href="https://typst.app/docs/">官网教程-英文</a></li><li><a href="https://typst.app/universe/">https://typst.app/universe/</a></li></ul><blockquote><p>使用方式除了官网编辑器之外，还可以用Vscode安装插件<strong>Tinymistt Typst</strong>进行写作<br>此外Chrome浏览器在浏览Typst官网的时候在地址栏提供下载，可以安装到本地使用。<br>Typst听说是两个德国人被Latex折磨的不行之后自己发明出来的，是优秀的排版工具<br>我是为了写简历才学习使用的，此外还可以用来写论文一类的规范文件。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/posts/3259397556.html"/>
    <url>/posts/3259397556.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/posts/3259397556/file-20241023133230490.png"></p><p><strong>MySQL相关知识总结</strong></p><span id="more"></span><h1 id="如何处理-mysql-的死锁问题"><a href="#如何处理-mysql-的死锁问题" class="headerlink" title="如何处理 mysql 的死锁问题"></a>如何处理 mysql 的死锁问题</h1><p><a href="https://xie.infoq.cn/article/71b956f9467eddb8c352bada1"># 如何处理 mysql 的死锁问题</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础理论知识补充</title>
    <link href="/posts/2782156371.html"/>
    <url>/posts/2782156371.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/posts/2782156371/file-20241023081927058.png"></p><p><strong>补充在计算机基础学习过程中遇到的疑惑点</strong></p><span id="more"></span><h1 id="数据总线双向三态"><a href="#数据总线双向三态" class="headerlink" title="数据总线双向三态"></a>数据总线双向三态</h1><p><strong>数据总线双向三态是一种在计算机硬件中用于数据传输的机制，它允许数据在总线上进行双向传输，并且可以处于高阻态</strong>。以下是对数据总线双向三态的具体说明：</p><ol><li><p><strong>双向性</strong>：数据总线的双向性意味着它可以支持数据的双向流动。具体来说，数据既可以通过总线从CPU传送到其他设备（如存储器或I/O接口），也可以从这些设备传送回CPU。这种双向性使得数据总线非常灵活，能够适应多种不同的数据传输需求[^1^]。</p></li><li><p><strong>三态特性</strong>：三态是指总线可以处于三种不同的状态：高电平（逻辑“1”）、低电平（逻辑“0”）和高阻态（通常用符号Z表示）。高阻态是一种特殊状态，在这种状态下，总线既不输出高电平也不输出低电平，相当于与外部电路断开，不会影响到其他设备的正常工作[^3^][^4^]。</p></li><li><p><strong>使能控制</strong>：三态门通过一个使能信号（EN）来控制其输出状态。当使能信号为高电平时，三态门正常工作，输出高电平或低电平；当使能信号为低电平时，三态门输出高阻态。这种设计使得多个设备可以共享同一条总线而不会发生冲突[^4^]。</p></li><li><p><strong>应用场景</strong>：数据总线双向三态广泛应用于各种计算机系统中，特别是在需要频繁进行数据交换的场景中，如内存访问、I/O操作等。此外，在FPGA（现场可编程门阵列）设计中，双向IO口也常使用三态门来实现数据的双向传输[^2^][^5^]。</p></li></ol><p>综上所述，数据总线双向三态是一种高效且灵活的数据传输机制，通过使能信号的控制，实现了数据的双向流动和高阻态输出，从而满足了复杂系统对数据传输的需求。</p><hr><h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><p>通用寄存器是<strong>处理器中用于存储数据和参与算术逻辑运算的重要组件</strong>。以下是对通用寄存器的详细介绍：</p><ol><li><p><strong>基本概念</strong>：通用寄存器是CPU内部用于暂时存放数据、指令和地址的存储单元。它们的主要功能包括存储临时数据、计算过程中的中间结果，以及作为指针来访问内存地址[^1^]。</p></li><li><p><strong>主要作用</strong>：通用寄存器在计算机系统中扮演着核心角色。它们不仅用于存储数据和指令，还参与到几乎所有的算术和逻辑运算中。例如，加法、减法、乘法和除法等操作都可能需要通用寄存器的参与[^2^]。</p></li><li><p><strong>特殊功能</strong>：除了基本的存储和运算功能外，某些通用寄存器还具有特殊的用途。例如，在8086处理器中，AX寄存器通常被用作累加器，用于执行乘法和除法运算；BX寄存器则常被用作基址寄存器，用于存储内存地址；CX寄存器作为计数器，用于循环和位移操作；DX寄存器则用于I/O操作和乘除运算中的数据暂存[^4^]。</p></li><li><p><strong>分类</strong>：根据不同的处理器架构和设计，通用寄存器可以分为整数寄存器和浮点寄存器两大类。整数寄存器主要用于存储整数数据，而浮点寄存器则用于存储浮点数数据。此外，一些处理器还将通用寄存器设计为具有多个子寄存器或寄存器组的形式，以便更好地支持不同的数据类型和操作[^2^]。</p></li><li><p><strong>应用</strong>：在程序设计中，特别是汇编语言编程中，程序员需要熟悉每个通用寄存器的一般用途和特殊用途，以便在程序中做到正确、合理地使用它们。通过合理利用通用寄存器，可以提高程序的执行效率和性能[^1^][^2^]。</p></li></ol><p>综上所述，通用寄存器在计算机系统中具有举足轻重的地位。它们不仅是数据存储和传输的关键工具，还是算术逻辑运算的核心参与者。</p><hr><h1 id="定点运算器"><a href="#定点运算器" class="headerlink" title="定点运算器"></a>定点运算器</h1><p><strong>定点运算器是一种专门用于执行定点数运算的硬件设备，广泛应用于计算机系统中进行数值计算和数据处理</strong>。以下是对定点运算器的详细介绍：</p><ol><li><strong>概念与应用</strong><ul><li><strong>概念定义</strong>：定点运算器是计算机中的一种重要组成部分，主要用于处理定点数运算。它通过固定小数点位置的方式，对整数和小数部分进行处理[^1^]。</li><li><strong>应用领域</strong>：定点运算器广泛应用于图像处理、音频处理、信号处理、通信系统以及嵌入式系统等领域。随着人工智能和深度学习技术的发展，定点运算器在神经网络模型的部署和推理过程中也发挥着重要作用[^1^]。</li></ul></li><li><strong>基本组成</strong><ul><li><strong>寄存器</strong>：寄存器用于存储操作数和运算结果，包括累加器和数据寄存器等[^1^][^5^]。</li><li><strong>运算单元</strong>：运算单元负责执行各种算术运算，如加法、减法、乘法和除法等[^1^][^3^]。</li><li><strong>控制逻辑</strong>：控制逻辑协调整个运算器的工作流程，控制操作数的输入输出和运算步骤的调度[^1^]。</li></ul></li><li><strong>工作原理</strong><ul><li><strong>操作数输入</strong>：将需要进行运算的定点数从外部输入到定点运算器的寄存器中[^1^]。</li><li><strong>运算操作</strong>：根据指定的运算类型，通过运算单元计算出结果[^1^]。</li><li><strong>结果输出</strong>：将运算得到的结果输出到指定的寄存器中，供后续的运算或输出到外部使用[^1^]。</li></ul></li><li><strong>关键技术</strong><ul><li><strong>乘法运算</strong>：定点运算器中的乘法运算需要考虑定点数的小数位取舍、溢出判断和乘法结果的精度保持等问题[^1^]。</li><li><strong>加减运算</strong>：定点数的加减运算需要考虑进位和溢出的处理，以及结果的精度保持[^1^]。</li></ul></li><li><strong>总线结构</strong><ul><li><strong>单总线结构</strong>：所有部件都接到同一总线上，同一时间内只能有一个操作数放在单总线上[^3^][^5^]。</li><li><strong>双总线结构</strong>：两条总线各自把数据送至ALU的输入端，两个操作数同时加到ALU进行计算[^3^][^5^]。</li><li><strong>三总线结构</strong>：旁路器的作用是不通过ALU实现通用寄存器内的数据传输，速度最快[^3^][^5^]。</li></ul></li><li><strong>性能优化</strong><ul><li><strong>流水线技术</strong>：采用流水线技术可以提高定点运算器的处理速度和效率[^4^]。</li><li><strong>位移技术</strong>：利用位移操作可以简化乘除法运算，提高运算速度[^4^]。</li><li><strong>预测技术</strong>：通过预测技术可以减少运算延迟，提高定点运算器的性能[^4^]。</li></ul></li><li><strong>设计原则</strong><ul><li><strong>指令系统兼容性</strong>：定点运算器的设计需要与指令系统兼容，确保能够正确执行各种指令[^5^]。</li><li><strong>机器字长考虑</strong>：机器字长决定了一次运算的位数和存储器的位数，影响定点运算器的设计[^5^]。</li><li><strong>体系结构适应性</strong>：定点运算器的设计需要考虑整个计算机系统的体系结构，确保其与其他部件的协同工作[^5^]。</li></ul></li></ol><p>综上所述，定点运算器是计算机中不可或缺的组成部分，它在数值计算和数据处理方面发挥着重要作用。了解定点运算器的基本概念、组成、工作原理和技术特点，有助于更好地理解和应用这一重要的计算机组件。</p><hr><h1 id="CPU内部的时钟频率"><a href="#CPU内部的时钟频率" class="headerlink" title="CPU内部的时钟频率"></a>CPU内部的时钟频率</h1><p>在计算机领域，CPU的时钟频率是衡量其处理速度的一个重要指标。它代表了CPU每秒钟能够执行的周期数，这个数字越高，通常意味着CPU的运算能力越强。</p><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><ul><li><p><strong>基本概念</strong>：时钟频率是指振荡器产生的输入脉冲信号的频率，这个频率是同步电路工作的基准[^1^]。</p></li><li><p><strong>单位</strong>：时钟频率的单位是赫兹（Hz），表示每秒周期性变化的次数[^2^]。</p></li><li><p><strong>重要性</strong>：它是评定CPU性能的重要指标之一，因为时钟频率直接影响着CPU每秒可以执行的指令数[^3^]。</p></li></ul><h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><ul><li><p><strong>命名由来</strong>：时钟频率之所以被称为“时钟”，是因为它就像时钟一样规律地摆动，为CPU提供稳定的工作节奏。CPU的所有操作都按照这个节奏进行，确保了指令的有序执行[^6^]。</p></li><li><p><strong>与时间的关系</strong>：时钟频率与时间紧密相关，它决定了CPU完成任务的速度。高频率意味着CPU可以在更短的时间内完成更多的工作[^7^]。</p></li><li><p><strong>技术实现</strong>：在技术上，CPU通过内部的时钟电路来产生和控制时钟频率。这个频率是通过晶体振荡器产生的，晶体振荡器根据其物理特性在特定条件下以固定频率振动，从而提供稳定的时钟信号[^9^]。</p></li><li><p><strong>发展历史</strong>：从早期的机械齿轮时钟到现代的电子振荡器，时钟技术的发展促进了现代计算机中时钟频率的应用。随着技术的进步，CPU的时钟频率也在不断提高，推动了计算机性能的提升[^10^]。</p></li><li><p><strong>与其他组件的关系</strong>：CPU的时钟频率不仅影响自身的运行速度，还影响与其他硬件组件的数据交换速率。例如，内存和外设也需要与CPU的时钟频率同步，以确保数据的正确传输[^11^]。</p></li><li><p><strong>性能限制因素</strong>：尽管时钟频率对CPU性能至关重要，但它并不是唯一的决定因素。CPU的架构、缓存大小、指令集等也会影响其最终性能[^3^]。</p></li><li><p><strong>能效考量</strong>：随着能源成本的上升和环境保护意识的增强，高时钟频率带来的高能耗问题不容忽视。因此，现代CPU设计中越来越注重能效比，即在提供高性能的同时降低能耗[^7^]。</p></li></ul><p>综上所述，CPU的时钟频率不仅是衡量其性能的关键指标，也是整个计算机系统设计和优化的核心要素。了解时钟频率的定义和它为何被称为“时钟”，有助于深入理解现代计算机的工作原理和性能提升的途径。</p><hr><h1 id="为什么Cache-不能由程序或者程序员访问是高速缓存的透明性"><a href="#为什么Cache-不能由程序或者程序员访问是高速缓存的透明性" class="headerlink" title="为什么Cache 不能由程序或者程序员访问是高速缓存的透明性"></a>为什么Cache 不能由程序或者程序员访问是高速缓存的透明性</h1><p>好的，关于Cache（高速缓存）的透明性，以下是一些解释：</p><ol><li><p><strong>定义与概念</strong>：Cache的透明性指的是在计算机系统中，Cache的存在和操作对程序员来说是不可见的。这意味着程序员不需要直接管理或控制Cache，也不需要为了适应Cache的特性而修改程序代码。</p></li><li><p><strong>透明性的体现</strong>：Cache的管理完全由硬件自动完成，包括数据的读取、写入、替换等操作。这些操作对程序员是透明的，即程序员无法直接感知到这些操作的发生。由于Cache的存在，程序的执行速度得到了提升，但这种提升对程序员来说是“透明”的，即他们不需要为此付出额外的努力或编写额外的代码。</p></li><li><p><strong>透明性的意义</strong>：Cache的透明性简化了程序员的工作，使他们可以专注于编写程序逻辑，而无需关注底层的存储细节。同时，它也使得计算机系统能够更高效地利用资源，提高整体性能。</p></li><li><p><strong>与非透明Cache的区别</strong>：非透明Cache需要程序员显式地控制和管理Cache，这增加了编程的复杂性和难度。而透明Cache则通过硬件自动管理，减轻了程序员的负担。</p></li><li><p><strong>实现方式</strong>：Cache的透明性是通过硬件和操作系统的设计和优化来实现的。例如，现代CPU通常采用多级Cache结构，并通过复杂的替换策略和写回策略来优化Cache的性能。同时，操作系统也会提供相应的支持，以确保Cache的正确性和一致性。</p></li><li><p><strong>对程序员的影响</strong>：虽然Cache对程序员来说是透明的，但这并不意味着程序员可以完全忽略Cache的存在。了解Cache的工作原理和特性对于优化程序性能仍然是非常重要的。然而，在实际编程中，程序员通常不需要直接操作Cache，而是通过编写高效的代码来充分利用Cache的优势。</p></li><li><p><strong>发展趋势</strong>：随着计算机技术的不断发展，Cache的容量和速度都在不断提升，其透明性也在进一步增强。未来的计算机系统可能会采用更先进的Cache技术和算法，以进一步简化程序员的工作并提高系统性能。</p></li></ol><p>综上所述，Cache的透明性是指其在计算机系统中的存在和操作对程序员来说是不可见的。这种透明性简化了程序员的工作，提高了系统性能，并推动了计算机技术的进步和发展。</p><hr><h1 id="集成电路"><a href="#集成电路" class="headerlink" title="集成电路"></a>集成电路</h1><p><strong>集成电路的全称是Integrated Circuit，简称IC</strong>。</p><h2 id="电源管理、时钟生成"><a href="#电源管理、时钟生成" class="headerlink" title="电源管理、时钟生成"></a>电源管理、时钟生成</h2><p><strong>电源管理（Power Management）是指系统在运行过程中对电源的有效控制，以优化功耗和性能；时钟生成（Clock Generation）则涉及为系统各部分提供同步信号，确保它们按照正确的时序工作</strong>。以下是这两个概念的具体介绍：</p><ol><li><strong>电源管理</strong><ul><li><strong>定义与目的</strong>：电源管理是指通过一系列技术和策略，有效控制和管理设备的电源消耗，以延长电池寿命、提高能效并降低运营成本。它涵盖了从硬件设计到软件实现的各个方面[^1^]。</li><li><strong>主要技术</strong>：动态电压频率调节（DVFS）、自适应电压调整（AVS）、电源模式转换（如休眠模式、待机模式）等是现代电源管理中的常用技术。这些技术可以根据系统负载动态调整电源供应，减少不必要的能源浪费[^1^]。</li><li><strong>应用场景</strong>：从个人电子设备（如智能手机、笔记本电脑）到数据中心的大型服务器系统，再到工业自动化和物联网设备，电源管理无处不在，对于提升设备续航能力、降低能耗具有重要意义[^1^]。</li></ul></li><li><strong>时钟生成</strong><ul><li><strong>定义与作用</strong>：时钟生成是指在数字系统中产生稳定、准确的时钟信号的过程。这些信号用于同步系统内各个组件的操作，确保数据处理和传输的准确性和一致性[^2^]。</li><li><strong>关键技术</strong>：锁相环（PLL）、晶体振荡器（Crystal Oscillators）和时钟分配网络（Clock Distribution Networks, CDN）是实现高质量时钟信号的关键组件。PLL可以增加时钟频率的稳定性，而CDN负责将时钟信号分配给系统的各个部分[^2^]。</li><li><strong>应用领域</strong>：从微处理器到FPGA，再到通信设备，时钟生成对于任何需要精确时间控制的数字系统都是必不可少的。特别是在高速数据传输和处理领域，高质量的时钟信号对于保证系统性能至关重要[^2^]。</li></ul></li></ol><p>综上所述，电源管理和时钟生成是现代电子系统中不可或缺的两大核心技术。它们分别从能源效率和时间准确性两个方面，共同支撑着系统的高效、稳定运行。</p>]]></content>
    
    
    <categories>
      
      <category>专业课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高等学习笔记</title>
    <link href="/posts/2782156371.html"/>
    <url>/posts/2782156371.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/posts/2782156371/file-20241023100726806.png"></p><p><strong>记录高等数学学习过程中的疑惑点</strong></p><span id="more"></span><h1 id="二阶线性微分方程"><a href="#二阶线性微分方程" class="headerlink" title="二阶线性微分方程"></a>二阶线性微分方程</h1><p>二阶线性微分方程是<strong>一类特殊的微分方程，其未知函数及其一阶、二阶导数都是一次方的</strong>。这类方程在数学和物理学中有广泛的应用。以下是对二阶线性微分方程的详细解析：</p><ol><li><p><strong>基本形式</strong>：二阶线性微分方程的标准形式为y’’+p(x)y’+q(x)y=f(x)，其中p(x), q(x), f(x)在某区间上连续[^1^]。当f(x)=0时，该方程称为齐次方程；当f(x)≠0时，称为非齐次方程[^2^]。</p></li><li><p><strong>解的结构</strong>：对于二阶线性微分方程，其解通常包含两个独立的任意常数，这意味着解不是唯一的[^1^]。对于初值问题，如给定初始条件y(x_0)=y_0, y’(x_0)=y_1，则在x_0的邻域内存在唯一的解[^1^]。</p></li><li><p><strong>求解方法</strong>：二阶线性微分方程的求解方式分为两类：一是二阶线性齐次微分方程，二是线性非齐次微分方程。齐次方程主要采用特征方程求解，而非齐次方程则在对应的齐次方程的通解上加上特解即为非齐次方程的通解[^2^]。</p></li><li><p><strong>特殊类型</strong>：二阶常系数线性微分方程是二阶线性微分方程的一种特殊形式，其中p和q为常数。这种类型的方程在工程技术及力学和物理学中有广泛的应用[^3^]。其求解方法包括待定系数法、多项式法、常数变易法和微分算子法等[^3^]。</p></li><li><p><strong>应用实例</strong>：二阶线性微分方程在许多实际问题中都有应用，如振动问题、热传导问题等。例如，简谐振子的位移随时间的变化可以用二阶线性微分方程来描述[^3^]。</p></li></ol><p>综上所述，二阶线性微分方程不仅是数学理论的重要组成部分，也是解决实际问题的强大工具。通过掌握其基本形式、解的结构、求解方法以及特殊类型，可以更好地理解和应用这一重要的数学概念。</p><hr><p><strong>二阶线性微分方程中的“二阶”指的是微分方程中未知函数的最高导数是二阶导数</strong>。</p><p>二阶导数在数学分析中表示函数变化的加速度，即速度的变化率。在物理问题中，这通常与物体的加速度相关联。例如，在简谐振子模型中，位移随时间的变化可以通过二阶导数来描述，反映了物体受力与其加速度之间的关系[^3^]。</p><p>二阶线性微分方程的标准形式为y’’+p(x)y’+q(x)y=f(x)，其中y’’代表未知函数y关于变量x的二阶导数。这种形式的方程在物理学和工程学中有广泛的应用，如在振动分析、电路理论等领域[^1^][^2^]。</p><hr><p><strong>二阶线性微分方程中的“线性”意味着微分方程中未知函数及其导数都是一次方的</strong>。</p><p>具体来说，这意味着在方程中，未知函数（通常表示为y）和其一阶导数（y’）、二阶导数（y’’）都以一次幂的形式出现。这种形式的方程称为线性微分方程[^1^][^2^]。</p><p>在线性微分方程中，未知函数及其各阶导数作为整体的一次幂，不包含这些变量的高次幂或它们之间的乘积[^2^]。例如，方程y’’+p(x)y’+q(x)y=f(x)中，y、y’和y’’都是一次方的，符合线性的定义[^1^]。</p><p>总的来说，线性特性使得这类微分方程的求解过程具有特定的规律性和简便性，是数学和物理问题中常见的一种形式。</p><h1 id="虚数单位-i-的运算公式"><a href="#虚数单位-i-的运算公式" class="headerlink" title="虚数单位 i 的运算公式"></a>虚数单位 i 的运算公式</h1><hr><p>在数学中，关于虚数单位 ( i ) 的运算公式主要涉及四则运算、幂运算和三角函数等。以下是一些常见的公式：</p><ol><li><p><strong>加法</strong></p><ul><li><strong>公式</strong>：((a + bi) + (c + di) = (a + c) + (b + d)i)</li><li><strong>解释</strong>：虚数相加时，分别将它们的实部和虚部相加[^1^][^2^]。</li></ul></li><li><p><strong>减法</strong></p><ul><li><strong>公式</strong>：((a + bi) - (c + di) = (a - c) + (b - d)i)</li><li><strong>解释</strong>：虚数相减时，分别将它们的实部和虚部相减[^1^][^2^]。</li></ul></li><li><p><strong>乘法</strong></p><ul><li><strong>公式</strong>：((a + bi)(c + di) = ac + (ad + bc)i - bd)</li><li><strong>解释</strong>：利用分配律展开后，再结合 (i^2 = -1) 进行化简[^1^][^2^][^3^]。</li></ul></li><li><p><strong>除法</strong></p><ul><li><strong>公式</strong>：(\frac{a + bi}{c + di} = \frac{ac + bd}{c^2 + d^2} + \frac{bc - ad}{c^2 + d^2}i)</li><li><strong>解释</strong>：首先将分子分母同时乘以分母的共轭复数，使分母变为实数，然后进行除法运算并化简[^1^][^2^][^3^]。</li></ul></li><li><p><strong>幂运算</strong></p><ul><li><strong>公式</strong>：(i^2 = -1)，(i^3 = -i)，(i^4 = 1)，以此类推，形成一个周期为4的循环[^3^][^4^]。</li><li><strong>解释</strong>：虚数单位 (i) 的幂运算具有周期性，每4次幂运算后回到原点。</li></ul></li><li><p><strong>三角函数</strong></p><ul><li><strong>正弦函数</strong>：(\sin(a + bi) = \sin(a)\cos(bi) + \cos(a)\sin(bi) = \sin(a)\cosh(b) + i\sinh(b)\cos(a))</li><li><strong>余弦函数</strong>：(\cos(a - bi) = \cos(a)\cos(bi) + \sin(a)\sin(bi) = \cos(a)\cosh(b) + i\sinh(b)\sin(a))</li><li><strong>正切函数</strong>：(\tan(a + bi) = \frac{\sin(a + bi)}{\cos(a + bi)})</li><li><strong>余切函数</strong>：(\cot(a + bi) = \frac{\cos(a + bi)}{\sin(a + bi)})</li><li><strong>正割函数</strong>：(\sec(a + bi) = \frac{1}{\cos(a + bi)})</li><li><strong>余割函数</strong>：(\csc(a + bi) = \frac{1}{\sin(a + bi)})</li><li><strong>解释</strong>：这些三角函数公式将实数域的三角函数扩展到复数域，通过引入双曲函数来处理虚部[^2^][^4^]。</li></ul></li><li><p><strong>复数模和共轭</strong></p><ul><li><strong>模</strong>：对于复数 (a + bi)，其模为 (\sqrt{a^2 + b^2})。</li><li><strong>共轭</strong>：复数 (a + bi) 的共轭复数为 (a - bi)。</li><li><strong>解释</strong>：模用于表示复数的大小，共轭复数在复数的除法运算中有重要作用。</li></ul></li></ol><p>总的来说，这些公式构成了虚数单位 (i) 的基本运算框架，是理解和解决复数问题的基础。</p><h1 id="虚数和复数的区别"><a href="#虚数和复数的区别" class="headerlink" title="虚数和复数的区别"></a>虚数和复数的区别</h1><hr><p>虚数和复数是数学中两个重要的概念，它们在数系中具有不同的地位和作用。下面将详细分析虚数和复数的区别：</p><ol><li><strong>定义与表示</strong><ul><li><strong>虚数</strong>：虚数定义为形如a+bi的数，其中a和b是实数，且b≠0，i² = -1[^3^]。虚数的实部a对应平面上的横轴，虚部b对应纵轴[^5^]。</li><li><strong>复数</strong>：复数通常表示为a+bi的形式，其中a和b都是实数，i为虚数单位[^4^]。复数包括实数和虚数，当b=0时，复数即为实数；当a=0且b≠0时，复数称为纯虚数[^2^]。</li></ul></li><li><strong>历史背景</strong><ul><li><strong>虚数</strong>：虚数的概念由17世纪著名数学家笛卡尔创立，最初被认为是“虚构”的数字，后来发现虚数在解决代数方程中有重要作用[^3^]。</li><li><strong>复数</strong>：复数的历史可以追溯到公元1世纪，希腊数学家海伦首次考虑了复数方根的问题。经过多个世纪的发展，复数逐渐被接受并广泛应用于数学、物理等领域[^4^]。</li></ul></li><li><strong>运算规则</strong><ul><li><strong>虚数</strong>：虚数的加法、乘法等运算遵循特定的规则，例如(a+bi)±(c+di)=(a±c)+(b±d)i，(a+bi)(c+di)=(ac-bd)+(ad+bc)i[^3^]。</li><li><strong>复数</strong>：复数同样有加法、乘法等运算规则，但更为广泛。例如，复数的共轭、模等概念在虚数中并不适用[^4^]。</li></ul></li><li><strong>几何意义</strong><ul><li><strong>虚数</strong>：虚数可以在复平面上表示为点或向量，其实部和虚部分别对应横轴和纵轴[^5^]。</li><li><strong>复数</strong>：复数不仅可以在复平面上表示为点，还可以通过极坐标形式表示，其实部和虚部构成复数的模和幅角[^4^]。</li></ul></li><li><strong>应用领域</strong><ul><li><strong>虚数</strong>：虚数在数学分析、物理学中有广泛应用，特别是在解决某些类型的方程和函数问题时[^1^]。</li><li><strong>复数</strong>：复数的应用更加广泛，涵盖了工程学、信号处理、量子力学等多个领域。复数的理论为许多科学问题的解决提供了基础[^2^]。</li></ul></li><li><strong>哲学意义</strong><ul><li><strong>虚数</strong>：虚数的存在挑战了人们对数字的传统认知，它的引入拓宽了数学的边界[^3^]。</li><li><strong>复数</strong>：复数不仅在数学上有重要地位，还在哲学上引发了对现实世界本质的思考。复数理论的发展促进了对数学抽象思维的理解[^4^]。</li></ul></li></ol><p>综上所述，虚数和复数在数学中各自扮演着不可或缺的角色。虚数作为复数的一部分，其独特的性质和应用在数学史上具有重要意义。复数则因其广泛的应用和深刻的理论价值，成为现代数学不可或缺的一部分。</p><p><strong><a href="https://zhuanlan.zhihu.com/p/347136244">虚数与复数与欧拉公式</a></strong></p><h1 id="幂指函数求导"><a href="#幂指函数求导" class="headerlink" title="幂指函数求导"></a>幂指函数求导</h1><hr><p><img src="/posts/2782156371/img-20241027183039392.png"><br><img src="/posts/2782156371/img-20241027183044860.png"></p><hr><h1 id="余子式与代数余子式"><a href="#余子式与代数余子式" class="headerlink" title="余子式与代数余子式"></a>余子式与代数余子式</h1><p>余子式和代数余子式在<strong>定义、计算方法以及符号规则</strong>等方面存在区别，下面是详细的对比分析：</p><ol><li><p><strong>定义</strong></p><ul><li><strong>余子式</strong>：余子式是指在n阶行列式中划去元素aij所在的第i行与第j列后，剩下的n-1阶行列式[^1^][^2^]。</li><li><strong>代数余子式</strong>：代数余子式是在余子式的基础上乘以一个特定的符号因子(-1)^(i+j)，即Aij = (-1)^(i+j) * Mij[^3^][^4^]。</li></ul></li><li><p><strong>计算方法</strong></p><ul><li><strong>余子式</strong>：直接计算去掉特定行和列后的行列式。例如，对于5阶行列式，去掉第2行和第4列后得到的3阶行列式即为相应的余子式[^7^]。</li><li><strong>代数余子式</strong>：先计算余子式，然后根据位置添加符号。例如，若某元素的代数余子式为Mi j，则其代数余子式为Aij = (-1)^(i+j) * Mij[^3^]。</li></ul></li><li><p><strong>符号规则</strong></p><ul><li><strong>余子式</strong>：没有特定的符号规则，仅是去掉特定行和列后的行列式。</li><li><strong>代数余子式</strong>：符号由位置决定，(-1)^(i+j)，其中i和j分别是被去掉的行和列的索引[^3^][^4^]。</li></ul></li><li><p><strong>应用</strong></p><ul><li><strong>余子式</strong>：用于简化高阶行列式的计算。通过将高阶行列式转换为低阶行列式，可以更容易地进行数值计算[^5^][^6^]。</li><li><strong>代数余子式</strong>：用于行列式的展开定理，即拉普拉斯展开。行列式等于它的任意一行（或列）的元素与其对应的代数余子式的乘积之和[^8^][^9^]。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>高数</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高数</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java知识手册</title>
    <link href="/posts/1289796624.html"/>
    <url>/posts/1289796624.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>此处放一些个人收藏的技术网站，等待以后有时间自己沉淀技术博客文章</p><span id="more"></span><p><strong><a href="https://www.wdbyte.com/">未读代码</a></strong></p><p><strong><a href="https://www.yuque.com/vip6688/neho4x">Java八股文</a></strong></p><p><strong><a href="https://liaoxuefeng.com/books/java/introduction/index.html">廖雪峰官方网站</a></strong></p><p><strong><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg4MjU0OTM1OA==&amp;action=getalbum&amp;album_id=1664731708878848004&amp;scene=21#wechat_redirect">精通JVM系列</a></strong></p><p><strong><a href="https://www.cnkirito.moe/categories/">徐靖峰|个人博客</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面试</tag>
      
      <tag>八股文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo使用手册</title>
    <link href="/posts/1899991772.html"/>
    <url>/posts/1899991772.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/posts/1899991772/file-20241023124012083.png"></p><span id="more"></span><h1 id="Hexo搭建教程"><a href="#Hexo搭建教程" class="headerlink" title="Hexo搭建教程"></a>Hexo搭建教程</h1><h5 id="知乎教程"><a href="#知乎教程" class="headerlink" title="知乎教程"></a><a href="https://zhuanlan.zhihu.com/p/60578464">知乎教程</a></h5><h5 id="夜星梦尘"><a href="#夜星梦尘" class="headerlink" title="夜星梦尘"></a><a href="https://tech.yemengstar.com/hexo-tutorial-deploy-githubpages-beginner/">夜星梦尘</a></h5><h5 id="CSDN个性化搭建"><a href="#CSDN个性化搭建" class="headerlink" title="CSDN个性化搭建"></a><a href="https://blog.csdn.net/as480133937/article/details/100138838">CSDN个性化搭建</a></h5><hr><h1 id="Hexo文档"><a href="#Hexo文档" class="headerlink" title="Hexo文档"></a>Hexo文档</h1><h3 id="Hexo中文文档"><a href="#Hexo中文文档" class="headerlink" title="Hexo中文文档"></a><strong><a href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></strong></h3><h3 id="STUM文档"><a href="#STUM文档" class="headerlink" title="STUM文档"></a><a href="https://theme-stun.github.io/docs/zh-CN/guide/primary.html#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95">STUM文档</a></h3><hr><h1 id="Formatter介绍"><a href="#Formatter介绍" class="headerlink" title="Formatter介绍"></a>Formatter介绍</h1><table><thead><tr><th>属性名</th><th>描述</th><th>是否必需</th><th>默认值</th></tr></thead><tbody><tr><td>title</td><td>页面标题</td><td>是</td><td>-</td></tr><tr><td>date</td><td>页面创建日期</td><td>是</td><td>-</td></tr><tr><td>type</td><td>标签、分类和友情链接三个页面需要配置</td><td>是</td><td>-</td></tr><tr><td>updated</td><td>页面更新日期</td><td>否</td><td>-</td></tr><tr><td>description</td><td>页面描述</td><td>否</td><td>-</td></tr><tr><td>keywords</td><td>页面关键字</td><td>否</td><td>-</td></tr><tr><td>comments</td><td>显示页面评论模块（默认为true）</td><td>否</td><td>true</td></tr><tr><td>top_img</td><td>页面顶部图片</td><td>否</td><td>-</td></tr><tr><td>mathjax</td><td>显示mathjax（当设置mathjax的per_page: false时，才需要配置）</td><td>否</td><td>false</td></tr><tr><td>katex</td><td>显示katex（当设置katex的per_page: false时，才需要配置）</td><td>否</td><td>false</td></tr><tr><td>aside</td><td>显示侧边栏（默认为true）</td><td>否</td><td>true</td></tr><tr><td>highlight_shrink</td><td>配置代码框是否展开（true/false）（默认为设置中highlight_shrink的配置）</td><td>否</td><td>-</td></tr></tbody></table><blockquote><p>tips:以上这个表格的md是这样写的</p></blockquote><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">| 属性名       | 描述                                                         | 是否必需 | 默认值        |<br>|------------|------------------------------------------------------------|--------|-------------|<br>| title      | 页面标题                                                    | 是     | -           |<br>| date       | 页面创建日期                                                | 是     | -           |<br>| type       | 标签、分类和友情链接三个页面需要配置                          | 是     | -           |<br>| updated    | 页面更新日期                                                | 否     | -           |<br>| description| 页面描述                                                    | 否     | -           |<br>| keywords   | 页面关键字                                                  | 否     | -           |<br>| comments   | 显示页面评论模块（默认为<span class="hljs-literal">true</span>）                               | 否     | <span class="hljs-literal">true</span>        |<br>| top_img    | 页面顶部图片                                                | 否     | -           |<br>| mathjax    | 显示mathjax（当设置mathjax的<span class="hljs-attr">per_page</span>: <span class="hljs-literal">false</span>时，才需要配置）  | 否     | <span class="hljs-literal">false</span>       |<br>| katex      | 显示katex（当设置katex的<span class="hljs-attr">per_page</span>: <span class="hljs-literal">false</span>时，才需要配置）      | 否     | <span class="hljs-literal">false</span>       |<br>| aside      | 显示侧边栏（默认为<span class="hljs-literal">true</span>）                                     | 否     | <span class="hljs-literal">true</span>        |<br>| highlight_shrink | 配置代码框是否展开（<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>）（默认为设置中highlight_shrink的配置） | 否     | -           |<br></code></pre></td></tr></tbody></table></figure><hr><h1 id="Hexo分类多层级"><a href="#Hexo分类多层级" class="headerlink" title="Hexo分类多层级"></a>Hexo分类多层级</h1><ol><li><p><strong>父子分类</strong></p><figure class="highlight ldif"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">categories</span>:<br><span class="hljs-literal">-</span> Diary<br><span class="hljs-literal">-</span> Life<br></code></pre></td></tr></tbody></table></figure><p>会使分类Life成为Diary的子分类，而不是并列分类</p></li><li><p><strong>并列+子分类</strong><br>为文章添加多个分类，尝试一下list的方法</p><figure class="highlight ldif"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">categories</span>:<br><span class="hljs-literal">-</span> [Diary, PlayStation]<br><span class="hljs-literal">-</span> [Diary, Games]<br><span class="hljs-literal">-</span> [Life]<br></code></pre></td></tr></tbody></table></figure><p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类</p></li></ol><hr><h1 id="Hexo常用操作命令"><a href="#Hexo常用操作命令" class="headerlink" title="Hexo常用操作命令"></a>Hexo常用操作命令</h1><img src="/posts/1899991772/1899991772/hexo.png" class=""><hr><h1 id="Hexo-Obsidian高可用搭建说明"><a href="#Hexo-Obsidian高可用搭建说明" class="headerlink" title="Hexo+Obsidian高可用搭建说明"></a>Hexo+Obsidian高可用搭建说明</h1><h4 id="图片保存"><a href="#图片保存" class="headerlink" title="图片保存"></a>图片保存</h4><p>图片保存在Obsidian有自己的语法，要实现既可以在Ob上预览又可以在博客上显示出来需要一系列的设置</p><ol><li><strong>Ob上安装插件</strong><img src="/posts/1899991772/1899991772/file-20241021180920049.png" class=""></li><li><strong>配置Ob相关设置</strong><img src="/posts/1899991772/1899991772/file-20241021181007212.png" class=""><img src="/posts/1899991772/1899991772/file-20241021181012702.png" class=""></li><li><strong>安装插件hexo-asset–image</strong></li></ol><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">npm install hexo-asset-<span class="hljs-selector-tag">image</span> <span class="hljs-attr">--save</span><br></code></pre></td></tr></tbody></table></figure><ol start="4"><li><strong>修改_config.yml</strong><br>修改下列属性为true</li></ol><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></tbody></table></figure><p>以上步骤完成之后便可以正常使用<br>每次在Ob中保存图片便会生成如下格式路径</p><img src="/posts/1899991772/1899991772/file-20241021181834513.png" class=""><hr><h1 id="编辑器使用转型经验"><a href="#编辑器使用转型经验" class="headerlink" title="编辑器使用转型经验"></a>编辑器使用转型经验</h1><ul><li>Obsidian</li></ul><blockquote><p>适合编辑文本，编辑体验比vscode好<br>缺点是不适合插入图片，无法设置子分类，无法自动生成时间<br>使用简介，各种键入反应快捷</p></blockquote><ul><li>Vscode，</li></ul><blockquote><p>可以插入图片，可以设置子分类<br>缺点是编辑体验不如Obsidian好，预览显示有卡顿</p></blockquote><h1 id="压缩插件"><a href="#压缩插件" class="headerlink" title="压缩插件"></a>压缩插件</h1><p><strong>①Hexo-all-minifier</strong></p><p><a href="https://github.com/chenzhutian/hexo-all-minifier/blob/master/README.md">MD地址</a></p><h1 id="Fluid主题"><a href="#Fluid主题" class="headerlink" title="Fluid主题"></a>Fluid主题</h1><h2 id="Tag插件"><a href="#Tag插件" class="headerlink" title="Tag插件"></a>Tag插件</h2><figure class="highlight django"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">{% <span class="hljs-name">note</span> success %}</span><span class="language-xml"></span><br><span class="language-xml">文字 或者 `markdown` 均可</span><br><span class="language-xml"></span><span class="hljs-template-tag">{% <span class="hljs-name">endnote</span> %}</span><br></code></pre></td></tr></tbody></table></figure><h2 id="可选标签："><a href="#可选标签：" class="headerlink" title="可选标签："></a>可选标签：</h2><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><h2 id="行内标签"><a href="#行内标签" class="headerlink" title="行内标签"></a>行内标签</h2><figure class="highlight crystal"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-template-variable">{% label primary <span class="hljs-variable">@text</span> %}</span><br></code></pre></td></tr></tbody></table></figure><p>可选标签：</p><span class="label label-primary">text</span><span class="label label-default">text</span><span class="label label-info">text</span><span class="label label-success">text</span><span class="label label-warning">text</span><span class="label label-danger">text</span><h2 id="折叠块"><a href="#折叠块" class="headerlink" title="折叠块"></a>折叠块</h2><p>使用折叠块，可以折叠代码、图片、文字等任何内容，你可以在 markdown 中按如下格式：</p><figure class="highlight django"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">{% <span class="hljs-name">fold</span> info @title %}</span><span class="language-xml"></span><br><span class="language-xml">需要折叠的一段内容，支持 markdown</span><br><span class="language-xml"></span><span class="hljs-template-tag">{% <span class="hljs-name">endfold</span> %}</span><br></code></pre></td></tr></tbody></table></figure><p>info: 和行内标签类似的可选参数 title: 折叠块上的标题</p><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><figure class="highlight django"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">{% <span class="hljs-name">btn</span> url, text, title %}</span><br></code></pre></td></tr></tbody></table></figure><p>url：跳转链接<br>text：显示的文字<br>title：鼠标悬停时显示的文字（可选）</p><a class="btn" href="url" title="title" target="_blank">text</a><h2 id="组图"><a href="#组图" class="headerlink" title="组图"></a>组图</h2><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">{% gi total n1-n2-... %}<br>  !<span class="hljs-selector-attr">[]</span>(url)<br>  !<span class="hljs-selector-attr">[]</span>(url)<br>  !<span class="hljs-selector-attr">[]</span>(url)<br>  !<span class="hljs-selector-attr">[]</span>(url)<br>  !<span class="hljs-selector-attr">[]</span>(url)<br>{% endgi %}<br></code></pre></td></tr></tbody></table></figure><p>total：图片总数量，对应中间包含的图片 url 数量<br>n1-n2-…：每行的图片数量，可以省略，默认单行最多 3 张图，求和必须相等于 total，否则按默认样式</p><p>如<code>{% gi 5 3-2 %}</code>&nbsp;示例，代表共 5 张图，第一行 3 张图，第二行 2 张图。</p><hr><h1 id="优秀Hexo示范（Stun）主题"><a href="#优秀Hexo示范（Stun）主题" class="headerlink" title="优秀Hexo示范（Stun）主题"></a>优秀Hexo示范（Stun）主题</h1><h5 id="Case-1-向往的博客"><a href="#Case-1-向往的博客" class="headerlink" title="Case 1   向往的博客"></a><a href="https://uuanqin.top/">Case 1</a>   向往的博客</h5><h5 id="Case-2-stum主题作者的"><a href="#Case-2-stum主题作者的" class="headerlink" title="Case 2  stum主题作者的"></a><a href="https://liuyib.github.io/">Case 2</a>  stum主题作者的</h5><h5 id="Case-3-路人"><a href="#Case-3-路人" class="headerlink" title="Case 3   路人"></a><a href="https://zhangjichengcc.github.io/blog/">Case 3</a>   路人</h5><h5 id="Case-4-路人"><a href="#Case-4-路人" class="headerlink" title="Case 4  路人"></a><a href="https://longtong666.github.io/blog/">Case 4</a>  路人</h5><h5 id="Case-5-清河的博客"><a href="#Case-5-清河的博客" class="headerlink" title="Case 5  清河的博客"></a><a href="https://lasonneil.github.io/">Case 5</a>  清河的博客</h5><h5 id="Case6-君匡文集"><a href="#Case6-君匡文集" class="headerlink" title="Case6 君匡文集"></a><a href="https://literature.junkuang.fun/">Case6</a> 君匡文集</h5><h1 id="Hexo运行报错合集"><a href="#Hexo运行报错合集" class="headerlink" title="Hexo运行报错合集"></a>Hexo运行报错合集</h1><h2 id="AssertionError-ERR-ASSERTION-The-expression-evaluated-to-a-falsy-value"><a href="#AssertionError-ERR-ASSERTION-The-expression-evaluated-to-a-falsy-value" class="headerlink" title="AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:"></a>AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:</h2><p><img src="/posts/1899991772/img-20241028124035029.png"></p><ul><li>原因：<br><img src="/posts/1899991772/img-20241028124330560.png"></li><li>一开始我在网上搜索解决方法看到这句话，只有一个相关答案，我就在想有没有可能是转义错误，然后我测试了多个环节发现：</li><li><img src="/posts/1899991772/img-20241028124124310.png"></li><li>如果我在最外层加这种反单引号会导致报<code>AssertionError [ERR_ASSERTION]: The expression evaluated to a falsy value:</code>的错，我如果去掉单引号就变成了上面别人说的那种转义的错误，所以我就把这一整个删了发现正常了。</li><li>后面我发现，好像是因为分割线紧贴了这句话导致这句话格式变了，不再是正文格式，中间多留一行就能解决<img src="/posts/1899991772/img-20241028125238738.png"></li><li>对于这种小错误我也是真无奈，还好从坑里爬出来了，下次注意！</li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GithubPages</tag>
      
      <tag>Obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="/posts/2991444807.html"/>
    <url>/posts/2991444807.html</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/posts/2991444807/file-20241023082318762.png"></p><p>第一次使用hexo搭建个人博客</p>]]></content>
    
    
    <categories>
      
      <category>随意</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
